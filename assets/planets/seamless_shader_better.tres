[gd_resource type="Shader" format=2]

[resource]
code = "shader_type canvas_item;

uniform float fadeWidth;

uniform sampler2D temp_gradient: hint_black;
uniform float uTemperature = 0.0;

uniform vec4 uCold: hint_color = vec4(0.2, 0.4, 0.39, 1.0);
uniform vec4 uOcean: hint_color = vec4(0.01, 0.81, 1.0, 1.0);
uniform vec4 uTemperate: hint_color = vec4(0.3, 0.42, 0.26, 1.0);
uniform vec4 uWarm: hint_color = vec4(0.46, 0.55, 0.32, 1.0);
uniform vec4 uHot: hint_color = vec4(0.87, 0.75, 0.58, 1.0);

//based on https://github.com/meric/renderplanet
const float M_PI = 3.1415926535897932384626433832795;
uniform sampler2D vectors; //orthographic projection
uniform float rotate_angle;
//2.0 is a full rotation
uniform float time : hint_range(0,2.0) = 1.0;

uniform float uWaterLevel : hint_range(0,1) = 0.45;
uniform vec4 color_land : hint_color = vec4(0.0, 1.0, 0.0, 1.0);
uniform vec4 color_sea : hint_color = vec4(0.0, 1.0, 1.0, 1.0);

float map(float value, float inMin, float inMax, float outMin, float outMax) {
  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);
}

mat2 rotate2d(float _angle) {
    return mat2(vec2(cos(_angle), -sin(_angle)), vec2(sin(_angle), cos(_angle)));
}

//https://www.shadertoy.com/view/MdySR1
vec4 texture_seamless_horizontal(sampler2D tex, vec2 uv, float fadeW) {
	vec2 offsetuv = uv*vec2(1.0-fadeW, 1.0 - fadeW);
    
    float scaling = 1.0 - fadeWidth;
    float vBlend = clamp((uv.x-scaling)/fadeWidth, 0.0, 1.0);
    
    float q1Blend = (1.0-vBlend);
    vec2 q1Sample;
    q1Sample.x = fract(offsetuv.x + fadeWidth);
    q1Sample.y = fract(offsetuv.y + fadeWidth);
    vec4 tex1 = texture(tex, q1Sample); 
    vec4 q1Col = q1Blend * tex1;

    float q2Blend = vBlend;
    vec2 q2Sample;
    q2Sample.x = fract(offsetuv.x + (fadeWidth * 2.0));
    q2Sample.y = fract(offsetuv.y + fadeWidth);
    vec4 tex2 = texture(tex, q2Sample);
    vec4 q2Col = q2Blend * tex2;
    
	return q1Col + q2Col;
}

//based on Zarkonnen (https://github.com/Zarkonnen/GenGen)
vec4 biome_color(vec2 uv, float n) {
	float n3 = n*17.;
	float n2 = n*34.;
	
	//default values
	vec3 col = vec3(0.0);
	float rivers = 0.;
	vec3 ice = vec3(250./255.0, 250./255.0, 250./255.0);
	
	float temp = texture(temp_gradient, vec2(uv.y, 0.0)).r;
	//gradient goes from 0 to 1 and the biomes assume range of -1 to 1.5
	temp = map(temp, 0, 1, -1, 1.5);
	
	//mix in some noise
	temp = temp + (n3 *0.1) * n * 0.6 + uTemperature;
	
	//biomes
	//ocean is handled elsewhere
	float ocean_fact = 0.0;
	//float ocean_fact = min(1.0, 1.0 - smoothstep(0.19, 0.2, n - uWaterLevel) + rivers * (1.0 - smoothstep(0.01, 0.04, mod(temp - uv.x * 35.0 + 0.3, 1.0) + n * n * 0.35))) * smoothstep(-0.9, -0.75, temp);

	float ice_fact = max(0.0, 1.0 + 0.25 - smoothstep(-0.8, -0.6, temp));
	float cold_fact = max(0.0, 1.0 - ice_fact - ocean_fact - smoothstep(-0.4, 0.0, temp));
	float temperate_fact = max(0.0, 1.0 - ice_fact - cold_fact - ocean_fact - smoothstep(0.3, 0.8, temp));
	float warm_fact = max(0.0, 1.0 - ice_fact - cold_fact - temperate_fact - ocean_fact - smoothstep(1.05, 1.3, temp));
	float hot_fact = max(0.0, 1.0 - ocean_fact - ice_fact - cold_fact - temperate_fact - warm_fact);
	
	//col = uOcean.rgb * ocean_fact + ice * ice_fact;
	col = ice * ice_fact;
	
	vec3 biome_cols = uCold.rgb * cold_fact + uTemperate.rgb * temperate_fact + uWarm.rgb * warm_fact + uHot.rgb * hot_fact; 
	
	col = col + biome_cols;
	
	//temp visualization
	//col = mix(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), temp);
	
	//tint by temp
	col *= (0.7 + abs(temp + n * 0.2) * 0.3);
	// some color adjustments
	col *= 0.92 + step(0.1, mod(n2, 0.4)) * 0.08;
	//adds some slight texture
	col *= 1.0 + step(0.39, mod(n + uv.x, 0.4)) * 0.1;
	
	return vec4(col, 1.0);
}

void fragment() {	
	//rotating planet shader based on meric
	mat2 rotate_planet_matrix;

    rotate_planet_matrix = rotate2d(rotate_angle);

  vec2 rotated_coords = rotate_planet_matrix * (UV-vec2(0.5));
  rotated_coords += vec2(0.5);
  vec4 vector = texture(vectors, rotated_coords );

  // Retrieve planet texture pixel
  vec2 planet_coords;
  planet_coords.x = (vector.r + vector.g/255.0 + time)/2.0;
  planet_coords.y = vector.b + vector.a/255.0;
  if (planet_coords.x > 1.0) {
    planet_coords.x =  planet_coords.x - 1.0;
  }

  //clip to a circle
  if (distance(rotated_coords, vec2(0.5, 0.5)) > 0.5) {
    //return vector;
	COLOR = vector;
  }
  else {
	//vec4 col = vec4(1.0, 0.0, 0.0, 1.0);
	vec2 uv = planet_coords;	
	vec4 col_noise = texture_seamless_horizontal(TEXTURE, uv, fadeWidth);
	//vec4 col = texture(TEXTURE, planet_coords);
	
	// add some shadow
	//vec2 height_uv = uv;
	float height = col_noise.r;
	
	//colorize the CPU noise
	//vec4 col_noise = texture(TEXTURE, uv);
	vec4 col_planet = vec4(1.0);
	if (col_noise.b > uWaterLevel) {
		vec4 land_col = biome_color(uv, col_noise.r);
		col_planet = land_col;
		//col_planet = color_land;
	}
	else {
		col_planet = color_sea;
	}
	
	//output to screen
	//COLOR = vec4(height);
	// mix in some height/shading
	vec4 colr = mix(vec4(col_planet.rgb, 1.0), vec4(0.2, 0.2, 0.2, 1.0), height);
	
	//vec4 colr = vec4(col_planet.rgb, 1.0);
	
	COLOR = colr;
  }
}"
